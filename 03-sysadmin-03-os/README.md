# Домашнее задание 03-sysadmin-03-os

<br>

## Задание 1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.
Выполнив команду `strace /bin/bash -c 'cd /tmp'` находим системный вызов:
```
chdir("/tmp")
```

## Задание 2. Попробуйте использовать команду file на объекты разных типов в файловой системе.
Выполняем команду `strace file /dev/tty` и анализируем вывод.<br><br>
Находим файл определения типов для команды `file`: **/usr/share/misc/magic.mgc**
<br>

## Задание 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
Для обнуления открытого файла можно воспользоваться следующим способом:
```
echo > /proc/(pid)/fd/(filedescriptor)
```
Где **pid** и **filedescriptor** - это идентификаторы процесса из выводы команды **lsof**.
<br>

## Задание 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Зомби процессы не занимают ресурсы системы (CPU, RAM, IO).<br><br>
Они занимают только ресурс таблицы процессов. Если таблица процессов будет заполнена, то пользователь не сможет продолжить работу.
<br>

## Задание 5. В iovisor BCC есть утилита `opensnoop`. На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты?
Установил пакет `bpfcc-tools` и выполнил команду `opensnoop-bpfcc -d 1`:
```
PID    COMM               FD ERR PATH
506    systemd-journal    43   0 /proc/1043/status
506    systemd-journal    43   0 /proc/1043/status
506    systemd-journal    43   0 /proc/1043/comm
506    systemd-journal    43   0 /proc/1043/cmdline
506    systemd-journal    43   0 /proc/1043/status
506    systemd-journal    43   0 /proc/1043/attr/current
506    systemd-journal    43   0 /proc/1043/sessionid
506    systemd-journal    43   0 /proc/1043/loginuid
506    systemd-journal    43   0 /proc/1043/cgroup
506    systemd-journal    -1   2 /run/systemd/units/log-extra-fields:massad.service
506    systemd-journal    -1   2 /run/log/journal/ac51212d040545e0b7e000097d90fef5/system.journal
506    systemd-journal    -1   2 /run/log/journal/ac51212d040545e0b7e000097d90fef5/system.journal
238178 sshd                5   0 /var/log/btmp
506    systemd-journal    43   0 /proc/238178/comm
506    systemd-journal    43   0 /proc/238178/cmdline
506    systemd-journal    43   0 /proc/238178/status
506    systemd-journal    43   0 /proc/238178/attr/current
506    systemd-journal    43   0 /proc/238178/sessionid
506    systemd-journal    43   0 /proc/238178/loginuid
506    systemd-journal    43   0 /proc/238178/cgroup
506    systemd-journal    -1   2 /run/systemd/units/log-extra-fields:ssh.service
506    systemd-journal    -1   2 /run/log/journal/ac51212d040545e0b7e000097d90fef5/system.journal
506    systemd-journal    -1   2 /run/log/journal/ac51212d040545e0b7e000097d90fef5/system.journal
```

## Задание 6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.
Выполняем команду `man -s 2 uname` и находим следующую строку:
```
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
```

## Задание 7. Чем отличается последовательность команд через `;` и через `&&` в bash? Есть ли смысл использовать в bash `&&`, если применить `set -e`?
Символ `;` позволяет запускать команды последовательно. Однако, каждая из команд не влияет на успешность выполнения всех команд в строке.<br><br>
В отличии от `;` символ `&&` позволяет проверить что все команды в строке будут выполнены успешно. Если одна из завершит свою работу не с кодом **0**, то система вернёт код ошибки для всей строки команд.<br><br>
Команды `set -e` и `&&` хоть и позволяют получить одинаковый результат, но использование `&&` является более предпочтительным из-за удобства использования этого оператора в командах и скриптах.
<br>

## Задание 8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?
`set -euxo pipefail` облегчает отладку, выводя больше информации о выполнении скрипта и прерывая скрипт при сбое в какой-либо строке скрипта.<br><br>
**-e** - немедленно выйти, если команда завершилась с кодом, отличным от нуля.<br><br>
**-u** - проверить подстановку переменных и завершиться с ошибкой, если для переменной нет значения.<br><br>
**-x** - вывести команды и их аргументы по мере их выполнения.<br><br>
**-o pipefail** - позволяет гарантировать, что все команды в наборе выполнились с нулевым кодом, в противном случае будет возвращён статус последней команды завершившейся с ненулевым статусом.
<br>

## Задание 9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
Самый популярный статус процессов в **Linux**: ***"S Interruptible sleep (waiting for an event to complete)"***<br><br>
Дополнительные буквы означают:
```
< high-priority (not nice to other users)
N low-priority (nice to other users)
L has pages locked into memory (for real-time and custom IO)
s is a session leader
l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
+ is in the foreground process group
```
<br>
