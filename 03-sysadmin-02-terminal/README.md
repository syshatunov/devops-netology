# Домашнее задание 03-sysadmin-02-terminal

<br>

## Задание 1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.
Команда `cd` используется для изменения текущего рабочего каталога, она является встроенной командой в оболочку и реализована в большинстве Unix-подобных операционных системах.<br><br>
Т.к. это встроенная команда оболочки, она выполняется в собственном процессе оболочки.<br><br>
Например в Ubuntu 20.04 (в WSL) команда `type -a cd` не отображает файловое представление команды `cd`
```
$ type -a cd
cd is a shell builtin
```
В других системах может иметь файловое представление, например в /bin/cd
<br>

## Задание 2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?
```
grep -c <some_string> <some_file>
```

## Задание 3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
Процесс с PID `1` - это процесс инициализации (/sbin/init)
<br>

## Задание 4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
Пример команды: `ls /test 2>/dev/pts/1`<br><br>
Запускаем два терминала, командой `lsof -p $$` определяем идентификаторы терминалов: **/dev/pts/0** и **/dev/pts/1**.<br><br>
Для проверки создаём папку **test** (`mkdir /test`), с правами **600** (`chmod 600 /test`) и владельцем root (`chown root:root /test`).<br><br>
После этого выполним команду `ls /test 2>/dev/pts/1` на терминале **/dev/pts/0** и на терминале **/dev/pts/1** получим вывод: `ls: cannot open directory '/test': Permission denied`
<br>

## Задание 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
Пример:
```
echo "Text" > file1.txt
cat < file1.txt 1>file2.txt
cat file2.txt

test string
```

## Задание 6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
В графическом режиме между разными **TTY** можно переключаться при помощи комбинации клавиш ***Ctrl+Alt+F1-F7***.<br><br>
Для проверки можно зайти в систему, переключиться на **tty1** ***(Ctrl+Alt+F2)***, ввести команду
`echo test > /dev/tty1`.<br><br>
Далее возвращаемся в первую сессию, и в консоли увидим текст:
***test***
<br>

## Задание 7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
Команда `bash 5>&1` создаст новый процесс bash и перенаправит дескриптор с номером 5 в **stdout**.<br><br>
В системе изменения можно увидеть выполнив команду `ls -la /proc/$$/fd`<br><br>
Если выполнить команду `echo netology > /proc/$$/fd/5` после выполнения предыдущей команды, то на экран выведется сообщение **netology**.<br><br>
Если выполнить команду `echo netology > /proc/$$/fd/5` перед выполнением предыдущей команду, то получим сообщение об ошибке:
```
-bash: /proc/251/fd/5: No such file or directory
```
Т.к. дескриптор 5 ещё не определён и ничего не выводит в текущий **pty** (**/dev/pts/0**)
<br>

## Задание 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?
Да, получится.<br><br>
Можем поменять местами **stderr** и **stdout** через промежуточный дескриптор.<br><br>
Для примера можем использовать папку **/test** из 4 задания.
```
ls /test 5>&1 1>&2 2>&5 | cat > out.txt
```
В файл **out.txt** запишется сообщение:
```
ls: cannot open directory '/test': Permission denied"
```
Вывод **stdout** тоже не потеряется.
<br>

## Задание 9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
Команда `cat /proc/$$/environ` выводит на экран **Environment** переменные.<br><br>
Аналогичный вывод можно получить при помощи команды `ps e -p $$` или `env`.
<br>

## Задание 10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
`/proc/<PID>/cmdline` - это файл (доступный только для чтения) содержащий полную строку запуска процесса вместе с аргументами, только если этот процесс не является зомби, в этом случае в файле ничего не будет.<br><br>
`/proc/<PID>/exe` - в Linux версии 2.2 и более поздних этот файл содержит символическую ссылку, содержащую актуальный путь к исполняемому файлу. Попытка открыть её приведёт к открытию исполняемого файла.<br><br>
До Linux 2.0 `/proc/<PID>/exe` содержал указатель на исполняемый файл, который мог быть выполнен и выглядел как символическая ссылка.
<br>

## Задание 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
Самая старшая версия инструкция **SSE**, которую поддерживает процессор - **sse4_2**.
<br>

## Задание 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.
***Однако:***
```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
***Почитайте, почему так происходит, и как изменить поведение?***<br><br>
По умолчания **ssh** создает **tty** только в интерактивном режиме, принудительно создать **tty** можно при помощи ключа **-t**.
<br>

## Задание 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
Сделал перемещение процесса `htop`, вместо **screen** воспользовался **tmux** *(**screen** постоянно возвращал Permission denied)*
```
htop
Ctrl+Z
bg
jobs -l
[1]+    530 Stopped (signal)        htop
disown htop
tmux
reptyr 530
```
На экран вывелся результат команды `htop`.
<br>

## Задание 14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте? что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
Команда `tee` позволяет получить данные из **stdin** и записать их в **stdout**.<br><br>
Для команды `tee` можно повысить привелегии и запустить её от имени суперпользователя, в отличии от перенаправления.
<br>
